#!/usr/bin/env python

import sys, subprocess, os, shutil, glob

# interfaceDeps is a dictionary of interfaces to their depencencies. This is
# not the most elegant way to handle this, but in lieu of a better build system
# this works okay. Previously this dependency structure was found in qiproject
# files. This must not have cyclic dependencies.
interfaceDeps = {
        'nao':['core', 'pythonswig'],
        'motion':['rswalk2014','nao', 'lola'],
        'vision':['nao', 'lola', 'detect_lib'],
        'memory_test':[],
        'tool':['detect_lib_tool'],
        'core':[],
        'pythonswig':[],
        'headless':['detect_lib_tool'],
        'lola':['rswalk2014', 'nao'],
        'rswalk2014':['core'],
        'detect_lib':[],
        'detect_lib_tool':[],
        }
validInterfaces = interfaceDeps.keys()
allInterfaces = validInterfaces[:]
allInterfaces.remove('headless')
localInterfaces = ["tool", 'headless', 'detect_lib_tool']
robotInterfaces = ['nao','motion','vision', 'core', 'pythonswig', 'lola', 'rswalk2014']

NAO_HOME = os.getenv('NAO_HOME')
NAO_SOUND = os.getenv('NAO_SOUND') == "true" 

options = None

def getNumProcs():
  try:
    procs = int(os.getenv("NUM_PROCS"))
    return procs
  except: pass
  try:
    import multiprocessing
    return multiprocessing.cpu_count()
  except:
    print 'Getting number of processors via multiprocessing failed, using /proc/cpuinfo'
    p = subprocess.Popen('grep -c ^processor /proc/cpuinfo',shell=True,stdout=subprocess.PIPE)
    p.wait()
    out, err = p.communicate()
    numProcs = int(out)
    return numProcs

def prependDeps(seq):
    if not seq:
        return []
    else:
        result = []
        for s in seq:
            result.extend(prependDeps(interfaceDeps[s]))
            result.append(s)
        return result

def makeUnique(seq, idfun=None): 
  # order preserving
  if idfun is None:
    def idfun(x): return x
  seen = {}
  result = []
  for item in seq:
    marker = idfun(item)
    # in old Python versions:
    # if seen.has_key(marker)
    # but in new ones:
    if marker in seen: continue
    seen[marker] = 1
    result.append(item)
  return result

def sysCall(cmd,failureMessage='Command failed'):
  retcode = subprocess.call(cmd,shell=True)
  if retcode != 0:
    print >>sys.stderr,failureMessage
    playSound()
    if retcode <= 127:
      sys.exit(retcode)
    else:
      sys.exit(2)

def compileInterfaces(interfaces,options):
  flags='-j ' + str(getNumProcs())
  if len(interfaces) == 0:
    return
  for interface in list(interfaces):
    if interface in localInterfaces:
      print "COMPILING %s" % interface
      if not compileLocal(interface):
        print "Compile failed for %s" % interface
        return False
      interfaces.remove(interface)
  for interface in interfaces:
    print '-----------------------------------------'
    print 'COMPILING interface: %s' % interface
    if interface=='detect_lib':
      compile_detect_lib()
      continue
    build_dir = os.path.join(options.build_dir,interface)
    os.chdir(build_dir)
    cmd = "make %s" % flags
    print cmd
    sysCall(cmd,'Compile failed')

def compile_detect_lib(tool=False, clean=False):
  script_dir = os.path.join(NAO_HOME+'/', 'lib/detect_lib')
  os.chdir(script_dir)
  build_dir = os.path.join(script_dir,"build")
  build_script = "build.sh"
  move_dir = script_dir
  if tool:
    build_dir = os.path.join(script_dir,"build_tool")
    build_script = "build_tool.sh"
    move_dir = os.path.join(script_dir, "../64")
  if clean:
    if os.path.exists(build_dir):
      subprocess.call("cd %s; bash ../clean.sh" % build_dir, shell=True)
    lib_path = os.path.join(move_dir, "libdetect_lib.so")
    print 'REMOVING %s' % lib_path
    if os.path.exists(lib_path):
        os.remove(lib_path)
  else:
    sysCall('mkdir -p %s' % build_dir, 'Creating build directory failed')
    sysCall('bash %s' % build_script, 'Compile failed')
    sysCall('cp %s %s' % (os.path.join(build_dir, "libdetect_lib.so"),
        move_dir), 'Move failed')

def configureInterfaces(interfaces,flags,options):
  if len(interfaces) == 0:
    return
  for interface in list(interfaces):
    if interface in set(localInterfaces):
      if interface=='detect_lib_tool':
        interfaces.remove(interface)
        continue
      print 'here'
      print "CONFIGURING %s" % interface
      if not configureLocal(interface,options):
        print "Configure failed for %s" % interface
        return False
      interfaces.remove(interface)
  if len(interfaces) == 0: return True
  flags += ' -DFORCE_NO_CCACHE=1 '
  if options.textlog:
    flags += ' -DALLOW_DEBUG_LOG=true'
  if options.optimize:
    flags += " -DOPTIMIZE=true"
  for interface in interfaces:
    if interface=='detect_lib':
      continue
    print '-----------------------------------------'
    print 'CONFIGURING interfaces: %s' % ' '.join(interfaces)
    build_dir = os.path.join(options.build_dir, interface)
    sysCall("mkdir -p %s" % build_dir)
    os.chdir(build_dir)
    flags += " -DCMAKE_TOOLCHAIN_FILE=%s/build/cross-config.cmake" % NAO_HOME
    flags += " -DUSE_OPENCV3=1"
    cmd = "cmake %s/build/%s %s" % (NAO_HOME, interface, flags)
    print cmd
    sysCall(cmd)

def parseArgs(args):
  from optparse import OptionParser
  parser = OptionParser('''compile [options] interface [interface ...]
  all: %s
  everything: %s
  robot: %s''' % (' '.join(allInterfaces),' '.join(validInterfaces),' '.join(robotInterfaces))
  )
  parser.add_option('--debug',dest='debug',action='store_true',default=False,help='Compile debug version')
  parser.add_option('--textlog',dest='textlog',action='store_true',default=False,help='Enable text logging for the robot build')
  parser.add_option('--fast',dest='configure',action='store_false',default=True,help='Does NOT run configure before compiling, good if you\'re not add files, bad if you are')
  parser.add_option('--clean',dest='clean',action='store_true',default=False,help='Removes all build files for the specified interfaces (Need to specify debug or geode like normal)')
  parser.add_option("--sound",'-s',dest='enable_sound',action='store_true',default=False,help='Makes a sound when finished compiling')
  parser.add_option("--optimize",dest="optimize",action='store_true',default=False,help='Enable build optimizations for demos and games.')

  options,args = parser.parse_args(args)
  if len(args) == 0:
    parser.parse_args(['--help'])
    sys.exit(1)
  return options,args
 
def compileLocal(interface):
  if interface=='detect_lib_tool':
      compile_detect_lib(tool=True)
      return True
  build_dir = os.path.join(options.build_dir,interface)
  sysCall("%s/build/%s/link %s" % (NAO_HOME,interface,options.build_type))
  os.chdir(build_dir)
  sysCall("make -j%i" % getNumProcs())
  return True

def configureLocal(interface,options):
  build_dir = os.path.join(options.build_dir,interface)
  sysCall("mkdir -p %s" % build_dir)
  sysCall("%s/build/%s/link %s" % (NAO_HOME,interface,options.build_type))
  os.chdir(build_dir)
  build_type = ""
  if options.debug: build_type = "-DCMAKE_BUILD_TYPE=Debug"
  sysCall('cmake %s/build/%s %s' % (NAO_HOME,interface,build_type))
  return True

def cleanInterfaces(interfaces,options):
  for interface in interfaces:
    print 'removing interface', interface
    if interface=='detect_lib':
      compile_detect_lib(clean=True)
      continue
    elif interface=='detect_lib_tool':
      compile_detect_lib(tool=True, clean=True)
      continue
    base = options.build_dir
    path = os.path.join(base,interface)
    print 'REMOVING %s' % path
    if os.path.exists(path):
      shutil.rmtree(path)

def playSound():
  if options.enable_sound or NAO_SOUND:
    try:
      p = subprocess.Popen('mpg123 %s/bin/ding.mp3' % NAO_HOME,shell=True,stderr=subprocess.PIPE,stdout=subprocess.PIPE)
      p.communicate()
    except: pass

def main(args):
  buildDir = os.path.join(NAO_HOME,'build')
  os.chdir(buildDir)
  global options
  options,args = parseArgs(args)
  options.build_dir = os.path.join(NAO_HOME,'build','build')
  if options.debug:
    options.build_type = 'debug'
  elif options.optimize:
    options.build_type = 'optimized'
  else:
    options.build_type = 'release'
  options.build_dir = os.path.join(options.build_dir,options.build_type)

  flags = ''
  if options.debug:
    flags += '-DCMAKE_BUILD_TYPE=Debug '
  else:
    flags += ''

  # get interfaces to be compiled (e.g. vision, all)
  interfaces = []
  for arg in args:
    arg = arg.lower()
    if arg == 'all':
      interfaces.extend(allInterfaces)
    elif arg == 'everything':
      interfaces.extend(validInterfaces)
    elif arg == 'robot':
      interfaces.extend(robotInterfaces)
    elif arg == "python":
      interfaces.append("pythonswig")
    else:
      interfaces.append(arg.replace('/',''))
  if not options.clean:
      interfaces = prependDeps(interfaces)
  # make interfaces unique
  interfaces = makeUnique(interfaces)
  # check interfaces
  for interface in interfaces:
    if interface not in validInterfaces:
      print >>sys.stderr,'Interface not in list of validInterfaces: %s' % interface
      print >>sys.stderr,validInterfaces
      sys.exit(1)
  # do it
  origInterfaces = list(interfaces)
  if options.clean:
    response = raw_input('Clean %s (y/n): ' % ' '.join(interfaces))
    if response.lower() in ['y','yes']:
      cleanInterfaces(interfaces,options)
    else:
      print 'Aborting'
  else:
    if options.configure:  
      configureInterfaces(interfaces[:],flags,options)
    compileInterfaces(interfaces[:],options)
  playSound()

if __name__ == '__main__':
  main(sys.argv[1:])
